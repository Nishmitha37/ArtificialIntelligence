from collections import deque

# Goal state for 8-puzzle
GOAL_STATE = (1, 2, 3,
              4, 5, 6,
              7, 8, 0)

# Moves: up, down, left, right (delta index changes)
MOVES = {
    'UP': -3,
    'DOWN': 3,
    'LEFT': -1,
    'RIGHT': 1
}

def is_valid_move(zero_pos, move):
    if move == 'UP':
        return zero_pos >= 3
    if move == 'DOWN':
        return zero_pos <= 5
    if move == 'LEFT':
        return zero_pos % 3 != 0
    if move == 'RIGHT':
        return zero_pos % 3 != 2
    return False

def get_neighbors(state):
    neighbors = []
    zero_pos = state.index(0)

    for move, delta in MOVES.items():
        if is_valid_move(zero_pos, move):
            new_zero_pos = zero_pos + delta
            new_state = list(state)
            # Swap zero with the target tile
            new_state[zero_pos], new_state[new_zero_pos] = new_state[new_zero_pos], new_state[zero_pos]
            neighbors.append(tuple(new_state))
    return neighbors

def dls(state, goal, depth_limit, path, visited):
    if state == goal:
        return path

    if depth_limit == 0:
        return None

    visited.add(state)

    for neighbor in get_neighbors(state):
        if neighbor not in visited:
            result = dls(neighbor, goal, depth_limit - 1, path + [neighbor], visited)
            if result is not None:
                return result

    visited.remove(state)
    return None

def iddfs(start_state, goal_state):
    depth = 0
    while True:
        visited = set()
        result = dls(start_state, goal_state, depth, [start_state], visited)
        if result is not None:
            return result
        depth += 1

def print_puzzle(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()

if __name__ == "__main__":
    # Example start state (can be changed)
    start = (1, 2, 3,
             4, 0, 6,
             7, 5, 8)

    print("Start State:")
    print_puzzle(start)

    print("Solving with IDDFS...")
    solution_path = iddfs(start, GOAL_STATE)

    if solution_path:
        print(f"Solution found in {len(solution_path)-1} moves:")
        for step, state in enumerate(solution_path):
            print(f"Step {step}:")
            print_puzzle(state)
    else:
        print("No solution found.")
